<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Transactions</name>
    </assembly>
    <members>
        <member name="T:Castle.Transactions.Activities.Activity">
            <summary>
            	Value-object that encapsulates a transaction and is serializable across
            	app-domains.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Activities.Activity.EnlistDependentTask(System.Threading.Tasks.Task)">
            <summary>
            Enlist a dependent task in the current activity. These tasks will be awaited
            </summary>
            <param name="task">The task to await from the completion of the top most transaction.</param>
            <exception cref="T:System.InvalidOperationException">If there is no current topmost transaction</exception>
        </member>
        <member name="M:Castle.Transactions.Activities.Activity.Push(Castle.Transactions.ITransaction)">
            <summary>
            	Push a transaction onto the stack of transactions.
            </summary>
            <param name = "transaction"></param>
        </member>
        <member name="M:Castle.Transactions.Activities.Activity.Pop">
            <summary>
            	Return the top-most transaction from the stack of transactions.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.Transactions.Internal.TransactionLogic">
            <summary>
            Class with implementation-detail type algorithms.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Internal.TransactionLogic.ShouldFork(Castle.Transactions.ITransactionOptions,System.UInt32)">
            <summary>
            Gets whether the transaction options dictate that the transaction should
            be a fork of its parent given the stack depth it would be at, as denoted by
            the 'nextStackDepth' parameter.
            </summary>
            <param name="transactionOptions">The options to check forking for.</param>
            <param name="nextStackDepth">The stack depth this fork would result in.</param>
            <returns>Whether the fork should continue.</returns>
        </member>
        <member name="M:Castle.Transactions.Internal.TransactionLogic.ForkScopeFactory(Castle.Transactions.ITransactionManager,Castle.Transactions.ITransaction)">
            <summary>
            Returns a fork scope factory func.
            The func is a factory that creates an IDisposable. This IDisposable is a semaphore
            for the fork-cases, as it can be signalled from other threads. The IDisposable-part
            is for API convenience.
            </summary>
            <param name="manager">The transaction manager</param>
            <param name="tx">The transaction to use in the fork.</param>
            <returns>A factory function for the fork scope</returns>
        </member>
        <member name="T:Castle.Transactions.Internal.TxScope">
            <summary>
            	A TxScope sets the ambient transaction for the duration of its lifetime and then re-assigns the previous value.
            	This class is NOT for public consumption. Use it if you are dealing
            	with <see cref="T:System.Transactions.CommittableTransaction"/> and <see cref="T:System.Transactions.DependentTransaction"/>
            	manually (and not using the transaction services to do it); otherwise
            	the <see cref="T:Castle.Transactions.ITransactionManager"/> will take care of setting the 
            	correct static properties for you.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Internal.TxScope.#ctor(System.Transactions.Transaction,Castle.Core.Logging.ILogger)">
            <summary>
            	A TxScope sets the ambient transaction for the duration of its lifetime and then re-assigns the previous value.
            	This class is NOT for public consumption. Use it if you are dealing
            	with <see cref="T:System.Transactions.CommittableTransaction"/> and <see cref="T:System.Transactions.DependentTransaction"/>
            	manually (and not using the transaction services to do it); otherwise
            	the <see cref="T:Castle.Transactions.ITransactionManager"/> will take care of setting the 
            	correct static properties for you.
            </summary>
        </member>
        <member name="M:Castle.Transactions.IRetryPolicy.Retry(System.Exception)">
            <summary>
            </summary>
            <param name = "thrownException"></param>
            <returns>whether another retry should be made</returns>
        </member>
        <member name="P:Castle.Transactions.IRetryPolicy.Failures">
            <summary>
            	Gets the number of times the retry method has been called
            </summary>
        </member>
        <member name="T:Castle.Transactions.Activities.CallContextActivityManager">
            <summary>
              The call-context activity manager saves the stack of transactions on the call-stack-context. This is the recommended manager and the default, also.
            </summary>
        </member>
        <member name="T:Castle.Transactions.IActivityManager">
            <summary>
            	Abstracts approaches to keep transaction activities
            	that may differ based on the environments.
            </summary>
        </member>
        <member name="M:Castle.Transactions.IActivityManager.GetCurrentActivity">
            <summary>
            	Gets the current activity.
            </summary>
            <value>The current activity.</value>
        </member>
        <member name="T:Castle.Transactions.Helpers.ContractArgumentValidatorAttribute">
            <summary>
            	Enables factoring legacy if-then-throw into separate methods for reuse and full control over
            	thrown exception and arguments
            </summary>
        </member>
        <member name="T:Castle.Transactions.Helpers.ContractAbbreviatorAttribute">
            <summary>
            	Enables writing abbreviations for contracts that get copied to other methods
            </summary>
        </member>
        <member name="T:Castle.Transactions.Helpers.ContractOptionAttribute">
            <summary>
            	Allows setting contract and tool options at assembly, type, or method granularity.
            </summary>
        </member>
        <member name="T:Castle.Transactions.Internal.CreatedTransaction">
            <summary>
            Class that simply implements the data-bearing interface <see cref="T:Castle.Transactions.ICreatedTransaction"/>.
            </summary>
        </member>
        <member name="T:Castle.Transactions.ICreatedTransaction">
            <summary>
            	An interface denoting the data structure which
            	carries data about a created transaction.
            </summary>
        </member>
        <member name="M:Castle.Transactions.ICreatedTransaction.GetForkScope">
            <summary>
            	<para>Call this method from your implementor of the fork-join pattern
            		for the transaction created, in order to correctly notify the transaction manager of
            		the activity going on.</para>
            	<para>
            		The returned disposable instance needs to be thread-safe.
            	</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.Transactions.ICreatedTransaction.Transaction">
            <summary>
            	Gets the currently active transaction.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ICreatedTransaction.ShouldFork">
            <summary>
            	Gets whether the transaction manager from which this instance
            	was created allows the potential fork-operation.
            </summary>
        </member>
        <member name="T:Castle.Transactions.DefaultTransactionOptions">
            <summary>
            	Sample implementation of ITransactionOptions. Use this if you are using <see cref="T:Castle.Transactions.ITransactionManager"/> directly.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.IsolationLevel">
            <summary>
            	Gets the transaction isolation level.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.Mode">
            <summary>
            	Gets the transaction mode.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.DependentOption">
            <summary>
            	<para>Gets the dependent clone option, i.e. the option that
            	specifies what to do with the child/dependent transaction
            	if the parent transaction completes before. The default is
            	BlockCommitUntilComplete and unless you know what you are doing, this is
            	a recommended setting.</para>
            	<para>
            	If you are COMPLETELY SURE you want the main, non-forked transaction
            	to complete without caring for its forked transactions (i.e. racing to complete
            	with them an introducing the random execution patterns this brings), set this
            	property to the non-default RollbackIfNotComplete. This will throw
            	TransactionAbortedExceptions on all forked transactions, which will be silently dropped. 
            </para>
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.Fork">
            <summary>
            	Gets whether the current transaction's method should forked off. You might get deadlocks
            	if you have only set one thread on the thread pool.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.Timeout">
            <summary>
            	Gets the Timeout for this managed transaction. Beware that the timeout 
            	for the transaction option is not the same as your database has specified.
            	Often it's a good idea to let your database handle the transactions
            	timing out and leaving this option to its max value. Your mileage may vary though.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.AsyncCommit">
            <summary>
            	Version 3.1: Gets whether the commit should be done asynchronously. Default is false. If you have done a lot of work
            	in the transaction, an asynchronous commit might be preferrable.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionOptions.AsyncRollback">
            <summary>
            	Version 3.1: Gets whether a failed transaction should rollback asynchronously after notifying the caller of failure.
            </summary>
        </member>
        <member name="M:Castle.Transactions.DefaultTransactionOptions.Equals(Castle.Transactions.ITransactionOptions)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Transactions.DefaultTransactionOptions.Equals(Castle.Transactions.DefaultTransactionOptions)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Transactions.DefaultTransactionOptions.Equals(System.Object)">
            <summary>
            	Determines whether the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
            	true if the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />; otherwise, false.
            </returns>
            <param name = "obj">The <see cref = "T:System.Object" /> to compare with the current <see cref = "T:System.Object" />. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Castle.Transactions.DefaultTransactionOptions.GetHashCode">
            <summary>
            	Serves as a hash function for a particular type.
            </summary>
            <returns>
            	A hash code for the current <see cref = "T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Castle.Transactions.Helpers.EnumerableExtensions">
            <summary>
            Helper class with items originally from reactive extensions.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Helpers.EnumerableExtensions.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Perform an action as the sequence is enumerated. Is NOT eager, so you must call
            an eager operator to start the side-effects.
            </summary>
        </member>
        <member name="T:Castle.Transactions.IDependentAware">
            <summary>
            	An interface specifying whether the <see cref="T:Castle.Transactions.ITransaction"/> implementation
            	knows about its dependents. If the transaction class does not implement this interface
            	then dependent transcations that fail will not be awaited on the main thread, but instead
            	on the finalizer thread (not good!).
            </summary>
        </member>
        <member name="M:Castle.Transactions.IDependentAware.RegisterDependent(System.Threading.Tasks.Task)">
            <summary>
            	Registers a dependent task to wait for after Complete or Rollback has been called.
            </summary>
            <param name = "task">The task to await.</param>
        </member>
        <member name="T:Castle.Transactions.TransactionMode">
            <summary>Obsolete. Remove usages. This attribute does nothing anymore.</summary>
        </member>
        <member name="F:Castle.Transactions.TransactionMode.Unspecified">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Transactions.TransactionMode.NotSupported">
            <summary>use "Supress" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Transactions.TransactionMode.Requires">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Transactions.TransactionMode.RequiresNew">
            <summary>use "RequiresNew" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Transactions.TransactionMode.Supported">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="T:Castle.Transactions.IsolationMode">
            <summary>Obsolete. Remove usages. Use <see cref="T:System.Transactions.IsolationLevel"/> instead.</summary>
        </member>
        <member name="T:Castle.Transactions.ISynchronization">
             <summary>Obsolete. Remove usages. Use code like this instead:
             <code>using (var tx = _Tm.CreateTransaction(new DefaultTransactionOptions()).Value.Transaction)
            {
            	tx.Inner.EnlistVolatile(resource, EnlistmentOptions.EnlistDuringPrepareRequired);
            	tx.Complete();
            }</code>
             or alternatively resolve/reference in instance of <see cref="T:Castle.Transactions.ITransactionManager"/> and use 
             <code>(:m).CurrentTransaction.Value.Inner.EnlistResource( <see cref="T:System.Transactions.ISinglePhaseNotification"/> synchronization )</code> 
             instead.
             </summary>
        </member>
        <member name="M:Castle.Transactions.ISynchronization.BeforeCompletion">
            <summary>Use <see cref="T:System.Transactions.ISinglePhaseNotification"/> instead.</summary>
        </member>
        <member name="M:Castle.Transactions.ISynchronization.AfterCompletion">
            <summary>Use <see cref="T:System.Transactions.ISinglePhaseNotification"/> instead.</summary>
        </member>
        <member name="T:Castle.Transactions.CommitResourceException">
            <summary>
            These exceptions won't be thrown anymore. If you are using exceptions to validate your entities you should catch TransactionAbortedException instead of this.
            </summary>
        </member>
        <member name="T:Castle.Transactions.TransactionException">
            <summary>
            	Exception thrown when the transaction services code has problems.
            </summary>
        </member>
        <member name="M:Castle.Transactions.TransactionException.#ctor">
            <summary>
            	base c'tor
            </summary>
        </member>
        <member name="M:Castle.Transactions.TransactionException.#ctor(System.String)">
            <summary>
            	c'tor with message
            </summary>
            <param name = "message"></param>
        </member>
        <member name="M:Castle.Transactions.TransactionException.#ctor(System.String,System.Uri)">
            <summary>
            	c'tor with message and a uri (new Uri(...)).
            </summary>
            <param name = "message"></param>
            <param name = "helpLink">A link relating to the exception/offering guidance.</param>
        </member>
        <member name="T:Castle.Transactions.TransactionalConflictException">
            <summary>
            Thrown if a non-transacted file API and a transacted file API try and operate on the same inode/file.
            </summary>
        </member>
        <member name="T:Castle.Transactions.ITransaction">
            <summary>
            	<para>
            		Denotes a castle transaction. This is the main point of interaction between your code and
            		the transactional behaviour of it. Use the transaction manager <see cref="T:Castle.Transactions.ITransactionManager"/> to
            		rollback from within a transactional method.
            	</para><para>
            	       	Implementors of this class should do their best to provide a stable implementation
            	       	where Dispose, Rollback and Complete can be called idempotently. The get-property accessors must
            	       	not change state when gotten.</para>
            </summary>
        </member>
        <member name="M:Castle.Transactions.ITransaction.Dispose">
            <summary>
            	Dispose the resource/the transaction. It's important that you call this method
            	when you are using the transaction together with the transaction manager, but 
            	otherwise as well if you want deterministic disposal.
            </summary>
        </member>
        <member name="M:Castle.Transactions.ITransaction.Rollback">
            <summary>
            	Rolls the transaction back. This method is automatically called on (managed) dispose.
            </summary>
        </member>
        <member name="M:Castle.Transactions.ITransaction.Complete">
            <summary>
            	Completes the transaction. This method can only be called if the 
            	transaction is in the active state, i.e. begin has been called.
            </summary>
            <exception cref="T:System.Transactions.TransactionInDoubtException">
            	The exception that is thrown when an operation 
            	is attempted on a transaction that is in doubt, 
            	or an attempt is made to commit the transaction 
            	and the transaction becomes InDoubt. 
            </exception>
            <exception cref="T:System.Transactions.TransactionAbortedException">
            	The exception that is thrown when an operation is attempted on a transaction 
            	that has already been rolled back, or an attempt is made to commit 
            	the transaction and the transaction aborts.
            </exception>
            <exception cref="T:Castle.Transactions.TransactionException">An unknown problem occurred. 
            	For example the connection to the database was lost.</exception>
            <exception cref="T:System.AggregateException">
            	One or more dependent transactions failed when using the Fork=true option!
            </exception>
            <remarks>
            	It's up for grabs (i.e. github pull request) to correctly handle state on the two exceptions that may be thrown
            	and to implement sane retry logic for them. All I can guess is that this shouldn't happen
            	unless you run distributed transactions.
            </remarks>
        </member>
        <member name="P:Castle.Transactions.ITransaction.State">
            <summary>
            	Gets the tranaction state. Castle.Service.Transaction contains a number
            	of states which will allow you to reasin about the state.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransaction.CreationOptions">
            <summary>
            	Gets the options used to create this transaction.
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransaction.Inner">
            <summary>
            	<para>Gets the inner <see cref="T:System.Transactions.Transaction"/>,
            		which is the foundation upon which Castle.Transactions builds.
            		It can be either a <see cref="T:System.Transactions.CommittableTransaction"/> or a 
            		<see cref="T:System.Transactions.DependentTransaction"/> or a 
            		<see cref="T:System.Transactions.SubordinateTransaction"/>. A dependent transaction
            		can be used to handle concurrency in a nice way.</para>
            
            	<para>This property is null if the transaction's supervising coordinator (i.e.
            		either MS DTC [multiple resources/2PC] or KTM [kernel/2PC] or LTM on Windows)
            		is not based on LTM -- this is true (and hence the property null) for Kernel Transactions, i.e. registry
            		and file transactions that were started before other DTC/LTM-transacted resources.</para>
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransaction.LocalIdentifier">
            <summary>
            	Gets a local identifier unique to the underlying transaction. Contrary to the 
            	underlying System.Transactions.Transaction.TransactionInformation.LocalIdentifier
            	property, this identifier is unique also across committable/dependent transactions
            	whereas the former isn't. Hence, this identifier is well suited to implement
            	per-transaction resolve semantics where even a dependent transaction requires a new 'context'
            	of resolve.
            </summary>
            <remarks>
            As opposed to the local identifier on System.Transactions.Transaction.Current.LocalIdentifier
            this getter does not have side-effects and will return a value despite the inner transaction
            being disposed.
            </remarks>
        </member>
        <member name="T:Castle.Transactions.ITransactionManager">
            <summary>
            	The transaction manager takes care of the nitty-gritty details of managing the store for transactions and their data.
            	Its main use-case is creating the actual transactions, given the options for the transaction and the 
            	be the place-to-go-to for knowing what transactions are currently ambient on the current call context.
            </summary>
        </member>
        <member name="M:Castle.Transactions.ITransactionManager.CreateTransaction">
            <summary>
            	Create a new transaction with the default options <see cref="T:Castle.Transactions.DefaultTransactionOptions"/>. The default options
            	will create a new transaction. Only options with Supress = true will NOT create transactions.
            </summary>
            <returns>Maybe a created transaction. If the default options is to supress transactions, the maybe has no value.</returns>
        </member>
        <member name="M:Castle.Transactions.ITransactionManager.CreateTransaction(Castle.Transactions.ITransactionOptions)">
            <summary>
            	Create a new transaction, given the transaction options.
            </summary>
            <remarks>
            	<para>
            		<see cref="M:System.IDisposable.Dispose"/> the transaction, or transactions further ahead in time will not
            		work properly.
            	</para>
            	<para>
            		Also, beware that if you call this method on your own, you are responsible for setting
            		<see cref="P:System.Transactions.Transaction.Current"/> to the result's Inner property
            		and restoring the previous Current property at the end of that transaction.
            	</para>
            	<para>
            		The transaction interceptor (in AutoTx) takes care of this for you. The two projects
            		work very well together.
            	</para>
            </remarks>
            <param name="transactionOptions">Options to use for creating the new transaction.</param>
            <returns>Maybe a transaction, if the options specified it. If the default options is to supress transactions, the maybe has no value.</returns>
        </member>
        <member name="P:Castle.Transactions.ITransactionManager.CurrentTopTransaction">
            <summary>
            	<para>Gets the current transaction. If the program has a call context
            		located any methods further down the call-stack with methods with TransactionAttribute,
            		this property gets the top most transaction which is the parent of the CurrentTransaction.
            	</para>
            	<para>
            		Be aware that, when you call this property, only reads on pure properties on the transaction are thread-safe
            		and no methods that are not static are thread-safe. This property can be used with good results to get 
            		a transaction which you can use to register top-most resources in, such as rollback-aware NHibernate-session
            		managers which can refresh the session if there's a fault.
            	</para>
            	<para>
            		The value is Maybe.None() if there's no current transaction.
            	</para>
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionManager.CurrentTransaction">
            <summary>
            	<para>Gets the current transaction.
            		The value is Maybe.None() if no transaction is on the current call context.</para>
            	<para>
            		If the current method has TransactionScopeOption.Supress specified but is inside a current transaction, then
            		<see cref="P:System.Transactions.Transaction.Current"/> is null, but this property has the actual value of the transaction.</para>
            </summary>
        </member>
        <member name="P:Castle.Transactions.ITransactionManager.Count">
            <summary>
            	Gets the number of transactions on the current context
            	(in which calls to this interface is relevant). The default context
            	is the call context, based on the call stack.
            </summary>
        </member>
        <member name="T:Castle.Transactions.Maybe">
            <summary>
            	Static helper class for creating Maybe monads.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Maybe.Some``1(``0)">
            <summary>
            	Creates a new maybe monad with a value.
            </summary>
            <typeparam name = "TSome">The type of the value to set the monad to contain.</typeparam>
            <param name = "item">The item</param>
            <returns>A non-null maybe instance of the maybe monad.</returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Do``1(Castle.Transactions.Maybe{``0},System.Func{``0,Castle.Transactions.Maybe{``0}})">
            <summary>
            	Perform an operation f on the maybe, where f might or mightn't return a Maybe.Some{{T}}.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "f">A function to continue applying to the monad.</param>
            <returns>The same monad</returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Do``1(Castle.Transactions.Maybe{``0},System.Func{``0,``0})">
            <summary>
            	Perform
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Do``2(Castle.Transactions.Maybe{``0},System.Func{``0,Castle.Transactions.Maybe{``1}})">
            <summary>
            </summary>
            <typeparam name = "TSome"></typeparam>
            <typeparam name = "TOther"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Do``2(Castle.Transactions.Maybe{``0},System.Func{``0,``1})">
            <summary>
            </summary>
            <typeparam name = "TSome"></typeparam>
            <typeparam name = "TOther"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.OrDefault``1(Castle.Transactions.Maybe{``0},``0)">
            <summary>
            	Returns the maybe or the default value passed as a parameter.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "default"></param>
            <returns>The unwrapped value of the maybe or otherwise the default.</returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Amb``1(Castle.Transactions.Maybe{``0},System.Func{Castle.Transactions.Maybe{``0}})">
            <summary>
            	The <c>Ambient</c> operator, that selects the second option if the first is unavailable.
            	Because C# doesn't support lazy parameters, it's a func, i.e. a factory method for getting the
            	second option.
            </summary>
            <typeparam name = "TSome">The type of the maybe</typeparam>
            <param name = "firstOption">The first maybe, which is returned if it has a value</param>
            <param name = "secondOption">Evaluation if the first option fails.</param>
            <returns>Maybe TSome.</returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.OrThrow``1(Castle.Transactions.Maybe{``0},System.Func{System.Exception})">
            <summary>
            	If the maybe doesn't have a value, throws the exception yielded by the func.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "ex"></param>
            <returns>The item in the maybe.</returns>
        </member>
        <member name="M:Castle.Transactions.Maybe.Coerce``2(Castle.Transactions.Maybe{``0})">
            <summary>
            	Type-system hack, in leiu of covariant bind (or rather Do in this monad),
            	changes type of the monad from TImpl to TAssignable, where TImpl : TAssignable.
            	The coercion is still statically typed and correct.
            </summary>
            <typeparam name = "TImpl">The type to convert FROM</typeparam>
            <typeparam name = "TAssignable">The type to convert TO</typeparam>
            <param name = "maybe">The object invoked upon</param>
            <returns>A new type of the same kind of monad.</returns>
        </member>
        <member name="T:Castle.Transactions.Maybe`1">
            <summary>
            	An implementation of the maybe monad.
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="P:Castle.Transactions.Maybe`1.HasValue">
            <summary>
            	Gets whether the maybe has a value.
            </summary>
        </member>
        <member name="P:Castle.Transactions.Maybe`1.Value">
            <summary>
            	Gets the value.
            </summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:Castle.Transactions.Maybe`1.HasValue"/> is false.</exception>
        </member>
        <member name="M:Castle.Transactions.Transaction.Castle#Transactions#ITransaction#Dispose">
            Possible state changes
            
            Default -> Constructed
            Constructed -> Disposed
            Constructed -> Active
            Active -> CommittedOrCompleted (depends on whether we are committable or not)
            Active -> InDoubt
            Active -> Aborted
            Aborted -> Disposed	# an active transaction may be disposed and then dispose must take take of aborting
        </member>
        <member name="T:Castle.Transactions.TransactionAttribute">
            <summary>
            	Specifies a method as transactional. When adding this interface to a method you can use an inversion of control container
            	to intercept method calls to that method and perform the method transactionally. In the 'recommended' implementation,
            	you can use Windsor and the AutoTx Facility for this. Just write <code>(:IWindsorContainer).AddFacility&lt;AutoTxFacility&gt;();</code>
            	when you are registering your components.
            </summary>
        </member>
        <member name="M:Castle.Transactions.TransactionAttribute.Equals(Castle.Transactions.TransactionAttribute)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Transactions.TransactionAttribute.Equals(System.Object)">
            <summary>
            	Determines whether the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
            	true if the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />; otherwise, false.
            </returns>
            <param name = "obj">The <see cref = "T:System.Object" /> to compare with the current <see cref = "T:System.Object" />. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Castle.Transactions.TransactionAttribute.GetHashCode">
            <summary>
            	Serves as a hash function for a particular type.
            </summary>
            <returns>
            	A hash code for the current <see cref = "T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Castle.Transactions.TransactionAttribute.Timeout">
            <summary>
            	Gets or sets the transaction timeout. The timeout is often better
            	implemented in the database, so this value is by default <see cref="F:System.TimeSpan.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Castle.Transactions.TransactionAttribute.Fork">
            <summary>
            	Gets or sets whether the current transaction should be forked off as a unit of work to the thread pool.
            </summary>
        </member>
        <member name="P:Castle.Transactions.TransactionAttribute.AsyncCommit">
            <summary>
            	Gets or sets whether the commit should be done asynchronously. Default is false. If you have done a lot of work
            	in the transaction, an asynchronous commit might be preferrable.
            </summary>
        </member>
        <member name="P:Castle.Transactions.TransactionAttribute.AsyncRollback">
            <summary>
            	Whether to perform the rollback asynchronously. This means that a failed transaction cleans up asynchronously.
            </summary>
        </member>
        <member name="T:Castle.Transactions.TransactionManager">
            <summary>
              The default transaction manager that is capable of handling most combinations of <see cref="T:Castle.Transactions.ITransactionOptions"/> .
            </summary>
        </member>
        <member name="M:Castle.Transactions.TransactionManager.EnlistDependentTask(System.Threading.Tasks.Task)">
            <summary>
              Enlists a dependent task in the current top transaction.
            </summary>
            <param name="task"> The task to enlist; this task is the action of running a dependent transaction on the thread pool. </param>
        </member>
        <member name="T:Castle.Transactions.TransactionState">
            <summary>
            An enum of the possible states a transaction might take. Due to
            the concurrent nature of a transaction that is talking to a resource manager
            hosted in another thread and the nature of distributed software, the transaction
            state is only a best guess (there is no truth), based on what methods have been
            called on the Transaction. If, for example, a <see cref="T:System.Transactions.DependentTransaction"/>
            has Rollback() called on it, the parent transaction has no way of getting
            deterministically notified, so its state will still be active, until
            Commit() is called on it (or <see cref="T:Castle.Transactions.ITransaction"/>.Complete() in the case of the API);
            then <see cref="T:System.Transactions.TransactionAbortedException"/> will be thrown.
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.Default">
            <summary>
            	Initial state before c'tor run
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.Active">
            <summary>
            	When begin has been called and has returned.
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.InDoubt">
            <summary>
            	When the transaction is in doubt. This occurs if e.g. the durable resource
            	fails after Prepare but before the ACK for Commit has reached the application on
            	which this transaction framework is running.
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.CommittedOrCompleted">
            <summary>
            	When commit has been called and has returned successfully.
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.Aborted">
            <summary>
            	When first begin and then rollback has been called, or
            	a resource failed.
            </summary>
        </member>
        <member name="F:Castle.Transactions.TransactionState.Disposed">
            <summary>
            	When the dispose method has run.
            </summary>
        </member>
        <member name="T:Castle.Transactions.Utils.Fun">
            <summary>
            	A functional-programming class which can help in memoizing function calls,
            	i.e. cache them.
            </summary>
        </member>
        <member name="M:Castle.Transactions.Utils.Fun.Memoize``1(System.Func{``0})">
            <summary>
            	Memoize this function, indefinately.
            </summary>
            <typeparam name = "TRes">Result type</typeparam>
            <param name = "f">Function to memoize</param>
            <returns>A memoized function</returns>
        </member>
        <member name="M:Castle.Transactions.Utils.Fun.Memoize``2(System.Func{``0,``1})">
            <summary>
            	See <see cref="M:Castle.Transactions.Utils.Fun.Memoize``2(System.Func{``0,``1},System.TimeSpan,System.Func{``1,System.Boolean})"/>
            </summary>
            <typeparam name="TA"></typeparam>
            <typeparam name="TRes"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Transactions.Utils.Fun.Memoize``2(System.Func{``0,``1},System.TimeSpan,System.Func{``1,System.Boolean})">
            <summary>
            	Memoize this function.
            </summary>
            <typeparam name = "TA">First function argument</typeparam>
            <typeparam name = "TRes">Type of result</typeparam>
            <param name = "f">Function to memoize</param>
            <param name = "pDur">Duration during which to save the value.</param>
            <param name = "keepIt">Whether to save/memoize the function or not</param>
            <returns>A memoized function.</returns>
        </member>
        <member name="M:Castle.Transactions.Utils.Fun.Memoize``1(System.Func{``0},System.TimeSpan)">
            <summary>
            	Memoize this function, a given timespan.
            </summary>
            <typeparam name = "TRes">Result type</typeparam>
            <param name = "f">Function to memoize</param>
            <param name = "pDur">Timespan during which to keep the results.</param>
            <returns>A memoized function</returns>
        </member>
    </members>
</doc>
